/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (t, e) {
  if (typeof exports == "object" && typeof module != "undefined") {
    module.exports = e();
  } else if (typeof define == "function" && define.amd) {
    define(e);
  } else {
    (t = typeof globalThis != "undefined" ? globalThis : t || self).bootstrap = e();
  }
})(this, function () {
  "use strict";

  const t = "transitionend";
  const e = t => {
    let e = t.getAttribute("data-bs-target");
    if (!e || e === "#") {
      let i = t.getAttribute("href");
      if (!i || !i.includes("#") && !i.startsWith(".")) {
        return null;
      }
      if (i.includes("#") && !i.startsWith("#")) {
        i = `#${i.split("#")[1]}`;
      }
      e = i && i !== "#" ? i.trim() : null;
    }
    return e;
  };
  const i = t => {
    const i = e(t);
    if (i && document.querySelector(i)) {
      return i;
    } else {
      return null;
    }
  };
  const n = t => {
    const i = e(t);
    if (i) {
      return document.querySelector(i);
    } else {
      return null;
    }
  };
  const s = e => {
    e.dispatchEvent(new Event(t));
  };
  const o = t => !!t && typeof t == "object" && (t.jquery !== undefined && (t = t[0]), t.nodeType !== undefined);
  const r = t => o(t) ? t.jquery ? t[0] : t : typeof t == "string" && t.length > 0 ? document.querySelector(t) : null;
  const a = (t, e, i) => {
    Object.keys(i).forEach(n => {
      const s = i[n];
      const r = e[n];
      const a = r && o(r) ? "element" : (l = r) == null ? `${l}` : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase();
      var l;
      if (!new RegExp(s).test(a)) {
        throw new TypeError(`${t.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`);
      }
    });
  };
  const l = t => !!o(t) && t.getClientRects().length !== 0 && getComputedStyle(t).getPropertyValue("visibility") === "visible";
  const c = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (t.disabled !== undefined ? t.disabled : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false");
  const h = t => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof t.getRootNode == "function") {
      const e = t.getRootNode();
      if (e instanceof ShadowRoot) {
        return e;
      } else {
        return null;
      }
    }
    if (t instanceof ShadowRoot) {
      return t;
    } else if (t.parentNode) {
      return h(t.parentNode);
    } else {
      return null;
    }
  };
  const d = () => {};
  const u = t => {
    t.offsetHeight;
  };
  const f = () => {
    const {
      jQuery: t
    } = window;
    if (t && !document.body.hasAttribute("data-bs-no-jquery")) {
      return t;
    } else {
      return null;
    }
  };
  const p = [];
  const m = () => document.documentElement.dir === "rtl";
  const g = t => {
    var e;
    e = () => {
      const e = f();
      if (e) {
        const i = t.NAME;
        const n = e.fn[i];
        e.fn[i] = t.jQueryInterface;
        e.fn[i].Constructor = t;
        e.fn[i].noConflict = () => {
          e.fn[i] = n;
          return t.jQueryInterface;
        };
      }
    };
    if (document.readyState === "loading") {
      if (!p.length) {
        document.addEventListener("DOMContentLoaded", () => {
          p.forEach(t => t());
        });
      }
      p.push(e);
    } else {
      e();
    }
  };
  const _ = t => {
    if (typeof t == "function") {
      t();
    }
  };
  const b = (e, i, n = true) => {
    if (!n) {
      _(e);
      return;
    }
    const o = (t => {
      if (!t) {
        return 0;
      }
      let {
        transitionDuration: e,
        transitionDelay: i
      } = window.getComputedStyle(t);
      const n = Number.parseFloat(e);
      const s = Number.parseFloat(i);
      if (n || s) {
        e = e.split(",")[0];
        i = i.split(",")[0];
        return (Number.parseFloat(e) + Number.parseFloat(i)) * 1000;
      } else {
        return 0;
      }
    })(i) + 5;
    let r = false;
    const a = ({
      target: n
    }) => {
      if (n === i) {
        r = true;
        i.removeEventListener(t, a);
        _(e);
      }
    };
    i.addEventListener(t, a);
    setTimeout(() => {
      if (!r) {
        s(i);
      }
    }, o);
  };
  const v = (t, e, i, n) => {
    let s = t.indexOf(e);
    if (s === -1) {
      return t[!i && n ? t.length - 1 : 0];
    }
    const o = t.length;
    s += i ? 1 : -1;
    if (n) {
      s = (s + o) % o;
    }
    return t[Math.max(0, Math.min(s, o - 1))];
  };
  const y = /[^.]*(?=\..*)\.|.*/;
  const w = /\..*/;
  const E = /::\d+$/;
  const A = {};
  let T = 1;
  const O = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  const C = /^(mouseenter|mouseleave)/i;
  const k = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function L(t, e) {
    return e && `${e}::${T++}` || t.uidEvent || T++;
  }
  function x(t) {
    const e = L(t);
    t.uidEvent = e;
    A[e] = A[e] || {};
    return A[e];
  }
  function D(t, e, i = null) {
    const n = Object.keys(t);
    for (let s = 0, o = n.length; s < o; s++) {
      const o = t[n[s]];
      if (o.originalHandler === e && o.delegationSelector === i) {
        return o;
      }
    }
    return null;
  }
  function S(t, e, i) {
    const n = typeof e == "string";
    const s = n ? i : e;
    let o = P(t);
    if (!k.has(o)) {
      o = t;
    }
    return [n, s, o];
  }
  function N(t, e, i, n, s) {
    if (typeof e != "string" || !t) {
      return;
    }
    if (!i) {
      i = n;
      n = null;
    }
    if (C.test(e)) {
      const t = t => function (e) {
        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) {
          return t.call(this, e);
        }
      };
      if (n) {
        n = t(n);
      } else {
        i = t(i);
      }
    }
    const [o, r, a] = S(e, i, n);
    const l = x(t);
    const c = l[a] ||= {};
    const h = D(c, r, o ? i : null);
    if (h) {
      h.oneOff = h.oneOff && s;
      return;
    }
    const d = L(r, e.replace(y, ""));
    const u = o ? function (t, e, i) {
      return function n(s) {
        const o = t.querySelectorAll(e);
        for (let {
          target: r
        } = s; r && r !== this; r = r.parentNode) {
          for (let a = o.length; a--;) {
            if (o[a] === r) {
              s.delegateTarget = r;
              if (n.oneOff) {
                j.off(t, s.type, e, i);
              }
              return i.apply(r, [s]);
            }
          }
        }
        return null;
      };
    }(t, i, n) : function (t, e) {
      return function i(n) {
        n.delegateTarget = t;
        if (i.oneOff) {
          j.off(t, n.type, e);
        }
        return e.apply(t, [n]);
      };
    }(t, i);
    u.delegationSelector = o ? i : null;
    u.originalHandler = r;
    u.oneOff = s;
    u.uidEvent = d;
    c[d] = u;
    t.addEventListener(a, u, o);
  }
  function I(t, e, i, n, s) {
    const o = D(e[i], n, s);
    if (o) {
      t.removeEventListener(i, o, Boolean(s));
      delete e[i][o.uidEvent];
    }
  }
  function P(t) {
    t = t.replace(w, "");
    return O[t] || t;
  }
  const j = {
    on(t, e, i, n) {
      N(t, e, i, n, false);
    },
    one(t, e, i, n) {
      N(t, e, i, n, true);
    },
    off(t, e, i, n) {
      if (typeof e != "string" || !t) {
        return;
      }
      const [s, o, r] = S(e, i, n);
      const a = r !== e;
      const l = x(t);
      const c = e.startsWith(".");
      if (o !== undefined) {
        if (!l || !l[r]) {
          return;
        }
        I(t, l, r, o, s ? i : null);
        return;
      }
      if (c) {
        Object.keys(l).forEach(i => {
          (function (t, e, i, n) {
            const s = e[i] || {};
            Object.keys(s).forEach(o => {
              if (o.includes(n)) {
                const n = s[o];
                I(t, e, i, n.originalHandler, n.delegationSelector);
              }
            });
          })(t, l, i, e.slice(1));
        });
      }
      const h = l[r] || {};
      Object.keys(h).forEach(i => {
        const n = i.replace(E, "");
        if (!a || e.includes(n)) {
          const e = h[i];
          I(t, l, r, e.originalHandler, e.delegationSelector);
        }
      });
    },
    trigger(t, e, i) {
      if (typeof e != "string" || !t) {
        return null;
      }
      const n = f();
      const s = P(e);
      const o = e !== s;
      const r = k.has(s);
      let a;
      let l = true;
      let c = true;
      let h = false;
      let d = null;
      if (o && n) {
        a = n.Event(e, i);
        n(t).trigger(a);
        l = !a.isPropagationStopped();
        c = !a.isImmediatePropagationStopped();
        h = a.isDefaultPrevented();
      }
      if (r) {
        d = document.createEvent("HTMLEvents");
        d.initEvent(s, l, true);
      } else {
        d = new CustomEvent(e, {
          bubbles: l,
          cancelable: true
        });
      }
      if (i !== undefined) {
        Object.keys(i).forEach(t => {
          Object.defineProperty(d, t, {
            get: () => i[t]
          });
        });
      }
      if (h) {
        d.preventDefault();
      }
      if (c) {
        t.dispatchEvent(d);
      }
      if (d.defaultPrevented && a !== undefined) {
        a.preventDefault();
      }
      return d;
    }
  };
  const M = new Map();
  const H = {
    set(t, e, i) {
      if (!M.has(t)) {
        M.set(t, new Map());
      }
      const n = M.get(t);
      if (n.has(e) || n.size === 0) {
        n.set(e, i);
      } else {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`);
      }
    },
    get: (t, e) => M.has(t) && M.get(t).get(e) || null,
    remove(t, e) {
      if (!M.has(t)) {
        return;
      }
      const i = M.get(t);
      i.delete(e);
      if (i.size === 0) {
        M.delete(t);
      }
    }
  };
  class B {
    constructor(t) {
      if (t = r(t)) {
        this._element = t;
        H.set(this._element, this.constructor.DATA_KEY, this);
      }
    }
    dispose() {
      H.remove(this._element, this.constructor.DATA_KEY);
      j.off(this._element, this.constructor.EVENT_KEY);
      Object.getOwnPropertyNames(this).forEach(t => {
        this[t] = null;
      });
    }
    _queueCallback(t, e, i = true) {
      b(t, e, i);
    }
    static getInstance(t) {
      return H.get(r(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
    }
    static get VERSION() {
      return "5.1.3";
    }
    static get NAME() {
      throw new Error("You have to implement the static method \"NAME\", for each component!");
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  }
  const R = (t, e = "hide") => {
    const i = `click.dismiss${t.EVENT_KEY}`;
    const s = t.NAME;
    j.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) {
      if (["A", "AREA"].includes(this.tagName)) {
        i.preventDefault();
      }
      if (c(this)) {
        return;
      }
      const o = n(this) || this.closest(`.${s}`);
      t.getOrCreateInstance(o)[e]();
    });
  };
  class W extends B {
    static get NAME() {
      return "alert";
    }
    close() {
      if (j.trigger(this._element, "close.bs.alert").defaultPrevented) {
        return;
      }
      this._element.classList.remove("show");
      const t = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, t);
    }
    _destroyElement() {
      this._element.remove();
      j.trigger(this._element, "closed.bs.alert");
      this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = W.getOrCreateInstance(this);
        if (typeof t == "string") {
          if (e[t] === undefined || t.startsWith("_") || t === "constructor") {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t](this);
        }
      });
    }
  }
  R(W, "close");
  g(W);
  const $ = "[data-bs-toggle=\"button\"]";
  class z extends B {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = z.getOrCreateInstance(this);
        if (t === "toggle") {
          e[t]();
        }
      });
    }
  }
  function q(t) {
    return t === "true" || t !== "false" && (t === Number(t).toString() ? Number(t) : t === "" || t === "null" ? null : t);
  }
  function F(t) {
    return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);
  }
  j.on(document, "click.bs.button.data-api", $, t => {
    t.preventDefault();
    const e = t.target.closest($);
    z.getOrCreateInstance(e).toggle();
  });
  g(z);
  const U = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${F(e)}`, i);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${F(e)}`);
    },
    getDataAttributes(t) {
      if (!t) {
        return {};
      }
      const e = {};
      Object.keys(t.dataset).filter(t => t.startsWith("bs")).forEach(i => {
        let n = i.replace(/^bs/, "");
        n = n.charAt(0).toLowerCase() + n.slice(1, n.length);
        e[n] = q(t.dataset[i]);
      });
      return e;
    },
    getDataAttribute: (t, e) => q(t.getAttribute(`data-bs-${F(e)}`)),
    offset(t) {
      const e = t.getBoundingClientRect();
      return {
        top: e.top + window.pageYOffset,
        left: e.left + window.pageXOffset
      };
    },
    position: t => ({
      top: t.offsetTop,
      left: t.offsetLeft
    })
  };
  const V = {
    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
    children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
    parents(t, e) {
      const i = [];
      let n = t.parentNode;
      while (n && n.nodeType === Node.ELEMENT_NODE && n.nodeType !== 3) {
        if (n.matches(e)) {
          i.push(n);
        }
        n = n.parentNode;
      }
      return i;
    },
    prev(t, e) {
      let i = t.previousElementSibling;
      while (i) {
        if (i.matches(e)) {
          return [i];
        }
        i = i.previousElementSibling;
      }
      return [];
    },
    next(t, e) {
      let i = t.nextElementSibling;
      while (i) {
        if (i.matches(e)) {
          return [i];
        }
        i = i.nextElementSibling;
      }
      return [];
    },
    focusableChildren(t) {
      const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", "[contenteditable=\"true\"]"].map(t => `${t}:not([tabindex^="-"])`).join(", ");
      return this.find(e, t).filter(t => !c(t) && l(t));
    }
  };
  const K = "carousel";
  const X = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: "hover",
    wrap: true,
    touch: true
  };
  const Y = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  };
  const Q = "next";
  const G = "prev";
  const Z = "left";
  const J = "right";
  const tt = {
    ArrowLeft: J,
    ArrowRight: Z
  };
  const et = "slid.bs.carousel";
  const it = "active";
  const nt = ".active.carousel-item";
  class st extends B {
    constructor(t, e) {
      super(t);
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(e);
      this._indicatorsElement = V.findOne(".carousel-indicators", this._element);
      this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent);
      this._addEventListeners();
    }
    static get Default() {
      return X;
    }
    static get NAME() {
      return K;
    }
    next() {
      this._slide(Q);
    }
    nextWhenVisible() {
      if (!document.hidden && l(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(G);
    }
    pause(t) {
      if (!t) {
        this._isPaused = true;
      }
      if (V.findOne(".carousel-item-next, .carousel-item-prev", this._element)) {
        s(this._element);
        this.cycle(true);
      }
      clearInterval(this._interval);
      this._interval = null;
    }
    cycle(t) {
      if (!t) {
        this._isPaused = false;
      }
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
      if (this._config && this._config.interval && !this._isPaused) {
        this._updateInterval();
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    }
    to(t) {
      this._activeElement = V.findOne(nt, this._element);
      const e = this._getItemIndex(this._activeElement);
      if (t > this._items.length - 1 || t < 0) {
        return;
      }
      if (this._isSliding) {
        j.one(this._element, et, () => this.to(t));
        return;
      }
      if (e === t) {
        this.pause();
        this.cycle();
        return;
      }
      const i = t > e ? Q : G;
      this._slide(i, this._items[t]);
    }
    _getConfig(t) {
      t = {
        ...X,
        ...U.getDataAttributes(this._element),
        ...(typeof t == "object" ? t : {})
      };
      a(K, t, Y);
      return t;
    }
    _handleSwipe() {
      const t = Math.abs(this.touchDeltaX);
      if (t <= 40) {
        return;
      }
      const e = t / this.touchDeltaX;
      this.touchDeltaX = 0;
      if (e) {
        this._slide(e > 0 ? J : Z);
      }
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        j.on(this._element, "keydown.bs.carousel", t => this._keydown(t));
      }
      if (this._config.pause === "hover") {
        j.on(this._element, "mouseenter.bs.carousel", t => this.pause(t));
        j.on(this._element, "mouseleave.bs.carousel", t => this.cycle(t));
      }
      if (this._config.touch && this._touchSupported) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      const t = t => this._pointerEvent && (t.pointerType === "pen" || t.pointerType === "touch");
      const e = e => {
        if (t(e)) {
          this.touchStartX = e.clientX;
        } else if (!this._pointerEvent) {
          this.touchStartX = e.touches[0].clientX;
        }
      };
      const i = t => {
        this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX;
      };
      const n = e => {
        if (t(e)) {
          this.touchDeltaX = e.clientX - this.touchStartX;
        }
        this._handleSwipe();
        if (this._config.pause === "hover") {
          this.pause();
          if (this.touchTimeout) {
            clearTimeout(this.touchTimeout);
          }
          this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval);
        }
      };
      V.find(".carousel-item img", this._element).forEach(t => {
        j.on(t, "dragstart.bs.carousel", t => t.preventDefault());
      });
      if (this._pointerEvent) {
        j.on(this._element, "pointerdown.bs.carousel", t => e(t));
        j.on(this._element, "pointerup.bs.carousel", t => n(t));
        this._element.classList.add("pointer-event");
      } else {
        j.on(this._element, "touchstart.bs.carousel", t => e(t));
        j.on(this._element, "touchmove.bs.carousel", t => i(t));
        j.on(this._element, "touchend.bs.carousel", t => n(t));
      }
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) {
        return;
      }
      const e = tt[t.key];
      if (e) {
        t.preventDefault();
        this._slide(e);
      }
    }
    _getItemIndex(t) {
      this._items = t && t.parentNode ? V.find(".carousel-item", t.parentNode) : [];
      return this._items.indexOf(t);
    }
    _getItemByOrder(t, e) {
      const i = t === Q;
      return v(this._items, e, i, this._config.wrap);
    }
    _triggerSlideEvent(t, e) {
      const i = this._getItemIndex(t);
      const n = this._getItemIndex(V.findOne(nt, this._element));
      return j.trigger(this._element, "slide.bs.carousel", {
        relatedTarget: t,
        direction: e,
        from: n,
        to: i
      });
    }
    _setActiveIndicatorElement(t) {
      if (this._indicatorsElement) {
        const e = V.findOne(".active", this._indicatorsElement);
        e.classList.remove(it);
        e.removeAttribute("aria-current");
        const i = V.find("[data-bs-target]", this._indicatorsElement);
        for (let e = 0; e < i.length; e++) {
          if (Number.parseInt(i[e].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) {
            i[e].classList.add(it);
            i[e].setAttribute("aria-current", "true");
            break;
          }
        }
      }
    }
    _updateInterval() {
      const t = this._activeElement || V.findOne(nt, this._element);
      if (!t) {
        return;
      }
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      if (e) {
        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
        this._config.interval = e;
      } else {
        this._config.interval = this._config.defaultInterval || this._config.interval;
      }
    }
    _slide(t, e) {
      const i = this._directionToOrder(t);
      const n = V.findOne(nt, this._element);
      const s = this._getItemIndex(n);
      const o = e || this._getItemByOrder(i, n);
      const r = this._getItemIndex(o);
      const a = Boolean(this._interval);
      const l = i === Q;
      const c = l ? "carousel-item-start" : "carousel-item-end";
      const h = l ? "carousel-item-next" : "carousel-item-prev";
      const d = this._orderToDirection(i);
      if (o && o.classList.contains(it)) {
        this._isSliding = false;
        return;
      }
      if (this._isSliding) {
        return;
      }
      if (this._triggerSlideEvent(o, d).defaultPrevented) {
        return;
      }
      if (!n || !o) {
        return;
      }
      this._isSliding = true;
      if (a) {
        this.pause();
      }
      this._setActiveIndicatorElement(o);
      this._activeElement = o;
      const f = () => {
        j.trigger(this._element, et, {
          relatedTarget: o,
          direction: d,
          from: s,
          to: r
        });
      };
      if (this._element.classList.contains("slide")) {
        o.classList.add(h);
        u(o);
        n.classList.add(c);
        o.classList.add(c);
        const t = () => {
          o.classList.remove(c, h);
          o.classList.add(it);
          n.classList.remove(it, h, c);
          this._isSliding = false;
          setTimeout(f, 0);
        };
        this._queueCallback(t, n, true);
      } else {
        n.classList.remove(it);
        o.classList.add(it);
        this._isSliding = false;
        f();
      }
      if (a) {
        this.cycle();
      }
    }
    _directionToOrder(t) {
      if ([J, Z].includes(t)) {
        if (m()) {
          if (t === Z) {
            return G;
          } else {
            return Q;
          }
        } else if (t === Z) {
          return Q;
        } else {
          return G;
        }
      } else {
        return t;
      }
    }
    _orderToDirection(t) {
      if ([Q, G].includes(t)) {
        if (m()) {
          if (t === G) {
            return Z;
          } else {
            return J;
          }
        } else if (t === G) {
          return J;
        } else {
          return Z;
        }
      } else {
        return t;
      }
    }
    static carouselInterface(t, e) {
      const i = st.getOrCreateInstance(t, e);
      let {
        _config: n
      } = i;
      if (typeof e == "object") {
        n = {
          ...n,
          ...e
        };
      }
      const s = typeof e == "string" ? e : n.slide;
      if (typeof e == "number") {
        i.to(e);
      } else if (typeof s == "string") {
        if (i[s] === undefined) {
          throw new TypeError(`No method named "${s}"`);
        }
        i[s]();
      } else if (n.interval && n.ride) {
        i.pause();
        i.cycle();
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        st.carouselInterface(this, t);
      });
    }
    static dataApiClickHandler(t) {
      const e = n(this);
      if (!e || !e.classList.contains("carousel")) {
        return;
      }
      const i = {
        ...U.getDataAttributes(e),
        ...U.getDataAttributes(this)
      };
      const s = this.getAttribute("data-bs-slide-to");
      if (s) {
        i.interval = false;
      }
      st.carouselInterface(e, i);
      if (s) {
        st.getInstance(e).to(s);
      }
      t.preventDefault();
    }
  }
  j.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", st.dataApiClickHandler);
  j.on(window, "load.bs.carousel.data-api", () => {
    const t = V.find("[data-bs-ride=\"carousel\"]");
    for (let e = 0, i = t.length; e < i; e++) {
      st.carouselInterface(t[e], st.getInstance(t[e]));
    }
  });
  g(st);
  const ot = "collapse";
  const rt = {
    toggle: true,
    parent: null
  };
  const at = {
    toggle: "boolean",
    parent: "(null|element)"
  };
  const lt = "show";
  const ct = "collapse";
  const ht = "collapsing";
  const dt = "collapsed";
  const ut = ":scope .collapse .collapse";
  const ft = "[data-bs-toggle=\"collapse\"]";
  class pt extends B {
    constructor(t, e) {
      super(t);
      this._isTransitioning = false;
      this._config = this._getConfig(e);
      this._triggerArray = [];
      const n = V.find(ft);
      for (let t = 0, e = n.length; t < e; t++) {
        const e = n[t];
        const s = i(e);
        const o = V.find(s).filter(t => t === this._element);
        if (s !== null && o.length) {
          this._selector = s;
          this._triggerArray.push(e);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    static get Default() {
      return rt;
    }
    static get NAME() {
      return ot;
    }
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let t;
      let e = [];
      if (this._config.parent) {
        const t = V.find(ut, this._config.parent);
        e = V.find(".collapse.show, .collapse.collapsing", this._config.parent).filter(e => !t.includes(e));
      }
      const i = V.findOne(this._selector);
      if (e.length) {
        const n = e.find(t => i !== t);
        t = n ? pt.getInstance(n) : null;
        if (t && t._isTransitioning) {
          return;
        }
      }
      if (j.trigger(this._element, "show.bs.collapse").defaultPrevented) {
        return;
      }
      e.forEach(e => {
        if (i !== e) {
          pt.getOrCreateInstance(e, {
            toggle: false
          }).hide();
        }
        if (!t) {
          H.set(e, "bs.collapse", null);
        }
      });
      const n = this._getDimension();
      this._element.classList.remove(ct);
      this._element.classList.add(ht);
      this._element.style[n] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const s = `scroll${n[0].toUpperCase() + n.slice(1)}`;
      this._queueCallback(() => {
        this._isTransitioning = false;
        this._element.classList.remove(ht);
        this._element.classList.add(ct, lt);
        this._element.style[n] = "";
        j.trigger(this._element, "shown.bs.collapse");
      }, this._element, true);
      this._element.style[n] = `${this._element[s]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      if (j.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
        return;
      }
      const t = this._getDimension();
      this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`;
      u(this._element);
      this._element.classList.add(ht);
      this._element.classList.remove(ct, lt);
      const e = this._triggerArray.length;
      for (let t = 0; t < e; t++) {
        const e = this._triggerArray[t];
        const i = n(e);
        if (i && !this._isShown(i)) {
          this._addAriaAndCollapsedClass([e], false);
        }
      }
      this._isTransitioning = true;
      this._element.style[t] = "";
      this._queueCallback(() => {
        this._isTransitioning = false;
        this._element.classList.remove(ht);
        this._element.classList.add(ct);
        j.trigger(this._element, "hidden.bs.collapse");
      }, this._element, true);
    }
    _isShown(t = this._element) {
      return t.classList.contains(lt);
    }
    _getConfig(t) {
      (t = {
        ...rt,
        ...U.getDataAttributes(this._element),
        ...t
      }).toggle = Boolean(t.toggle);
      t.parent = r(t.parent);
      a(ot, t, at);
      return t;
    }
    _getDimension() {
      if (this._element.classList.contains("collapse-horizontal")) {
        return "width";
      } else {
        return "height";
      }
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const t = V.find(ut, this._config.parent);
      V.find(ft, this._config.parent).filter(e => !t.includes(e)).forEach(t => {
        const e = n(t);
        if (e) {
          this._addAriaAndCollapsedClass([t], this._isShown(e));
        }
      });
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length) {
        t.forEach(t => {
          if (e) {
            t.classList.remove(dt);
          } else {
            t.classList.add(dt);
          }
          t.setAttribute("aria-expanded", e);
        });
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = {};
        if (typeof t == "string" && /show|hide/.test(t)) {
          e.toggle = false;
        }
        const i = pt.getOrCreateInstance(this, e);
        if (typeof t == "string") {
          if (i[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          i[t]();
        }
      });
    }
  }
  j.on(document, "click.bs.collapse.data-api", ft, function (t) {
    if (t.target.tagName === "A" || t.delegateTarget && t.delegateTarget.tagName === "A") {
      t.preventDefault();
    }
    const e = i(this);
    V.find(e).forEach(t => {
      pt.getOrCreateInstance(t, {
        toggle: false
      }).toggle();
    });
  });
  g(pt);
  var mt = "top";
  var gt = "bottom";
  var _t = "right";
  var bt = "left";
  var vt = "auto";
  var yt = [mt, gt, _t, bt];
  var wt = "start";
  var Et = "end";
  var At = "clippingParents";
  var Tt = "viewport";
  var Ot = "popper";
  var Ct = "reference";
  var kt = yt.reduce(function (t, e) {
    return t.concat([e + "-" + wt, e + "-" + Et]);
  }, []);
  var Lt = [].concat(yt, [vt]).reduce(function (t, e) {
    return t.concat([e, e + "-" + wt, e + "-" + Et]);
  }, []);
  var xt = "beforeRead";
  var Dt = "read";
  var St = "afterRead";
  var Nt = "beforeMain";
  var It = "main";
  var Pt = "afterMain";
  var jt = "beforeWrite";
  var Mt = "write";
  var Ht = "afterWrite";
  var Bt = [xt, Dt, St, Nt, It, Pt, jt, Mt, Ht];
  function Rt(t) {
    if (t) {
      return (t.nodeName || "").toLowerCase();
    } else {
      return null;
    }
  }
  function Wt(t) {
    if (t == null) {
      return window;
    }
    if (t.toString() !== "[object Window]") {
      var e = t.ownerDocument;
      return e && e.defaultView || window;
    }
    return t;
  }
  function $t(t) {
    return t instanceof Wt(t).Element || t instanceof Element;
  }
  function zt(t) {
    return t instanceof Wt(t).HTMLElement || t instanceof HTMLElement;
  }
  function qt(t) {
    return typeof ShadowRoot != "undefined" && (t instanceof Wt(t).ShadowRoot || t instanceof ShadowRoot);
  }
  const Ft = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function (t) {
        var i = e.styles[t] || {};
        var n = e.attributes[t] || {};
        var s = e.elements[t];
        if (zt(s) && Rt(s)) {
          Object.assign(s.style, i);
          Object.keys(n).forEach(function (t) {
            var e = n[t];
            if (e === false) {
              s.removeAttribute(t);
            } else {
              s.setAttribute(t, e === true ? "" : e);
            }
          });
        }
      });
    },
    effect: function (t) {
      var e = t.state;
      var i = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(e.elements.popper.style, i.popper);
      e.styles = i;
      if (e.elements.arrow) {
        Object.assign(e.elements.arrow.style, i.arrow);
      }
      return function () {
        Object.keys(e.elements).forEach(function (t) {
          var n = e.elements[t];
          var s = e.attributes[t] || {};
          var o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function (t, e) {
            t[e] = "";
            return t;
          }, {});
          if (zt(n) && Rt(n)) {
            Object.assign(n.style, o);
            Object.keys(s).forEach(function (t) {
              n.removeAttribute(t);
            });
          }
        });
      };
    },
    requires: ["computeStyles"]
  };
  function Ut(t) {
    return t.split("-")[0];
  }
  function Vt(t, e) {
    var i = t.getBoundingClientRect();
    return {
      width: i.width / 1,
      height: i.height / 1,
      top: i.top / 1,
      right: i.right / 1,
      bottom: i.bottom / 1,
      left: i.left / 1,
      x: i.left / 1,
      y: i.top / 1
    };
  }
  function Kt(t) {
    var e = Vt(t);
    var i = t.offsetWidth;
    var n = t.offsetHeight;
    if (Math.abs(e.width - i) <= 1) {
      i = e.width;
    }
    if (Math.abs(e.height - n) <= 1) {
      n = e.height;
    }
    return {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: n
    };
  }
  function Xt(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) {
      return true;
    }
    if (i && qt(i)) {
      var n = e;
      do {
        if (n && t.isSameNode(n)) {
          return true;
        }
        n = n.parentNode || n.host;
      } while (n);
    }
    return false;
  }
  function Yt(t) {
    return Wt(t).getComputedStyle(t);
  }
  function Qt(t) {
    return ["table", "td", "th"].indexOf(Rt(t)) >= 0;
  }
  function Gt(t) {
    return (($t(t) ? t.ownerDocument : t.document) || window.document).documentElement;
  }
  function Zt(t) {
    if (Rt(t) === "html") {
      return t;
    } else {
      return t.assignedSlot || t.parentNode || (qt(t) ? t.host : null) || Gt(t);
    }
  }
  function Jt(t) {
    if (zt(t) && Yt(t).position !== "fixed") {
      return t.offsetParent;
    } else {
      return null;
    }
  }
  function te(t) {
    var e = Wt(t);
    for (var i = Jt(t); i && Qt(i) && Yt(i).position === "static";) {
      i = Jt(i);
    }
    if (i && (Rt(i) === "html" || Rt(i) === "body" && Yt(i).position === "static")) {
      return e;
    } else {
      return i || function (t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
        if (navigator.userAgent.indexOf("Trident") !== -1 && zt(t) && Yt(t).position === "fixed") {
          return null;
        }
        for (var i = Zt(t); zt(i) && ["html", "body"].indexOf(Rt(i)) < 0;) {
          var n = Yt(i);
          if (n.transform !== "none" || n.perspective !== "none" || n.contain === "paint" || ["transform", "perspective"].indexOf(n.willChange) !== -1 || e && n.willChange === "filter" || e && n.filter && n.filter !== "none") {
            return i;
          }
          i = i.parentNode;
        }
        return null;
      }(t) || e;
    }
  }
  function ee(t) {
    if (["top", "bottom"].indexOf(t) >= 0) {
      return "x";
    } else {
      return "y";
    }
  }
  var ie = Math.max;
  var ne = Math.min;
  var se = Math.round;
  function oe(t, e, i) {
    return ie(t, ne(e, i));
  }
  function re(t) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, t);
  }
  function ae(t, e) {
    return e.reduce(function (e, i) {
      e[i] = t;
      return e;
    }, {});
  }
  const le = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: function (t) {
      var e;
      var i = t.state;
      var n = t.name;
      var s = t.options;
      var o = i.elements.arrow;
      var r = i.modifiersData.popperOffsets;
      var a = Ut(i.placement);
      var l = ee(a);
      var c = [bt, _t].indexOf(a) >= 0 ? "height" : "width";
      if (o && r) {
        var h = function (t, e) {
          return re(typeof (t = typeof t == "function" ? t(Object.assign({}, e.rects, {
            placement: e.placement
          })) : t) != "number" ? t : ae(t, yt));
        }(s.padding, i);
        var d = Kt(o);
        var u = l === "y" ? mt : bt;
        var f = l === "y" ? gt : _t;
        var p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c];
        var m = r[l] - i.rects.reference[l];
        var g = te(o);
        var _ = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0;
        var b = p / 2 - m / 2;
        var v = h[u];
        var y = _ - d[c] - h[f];
        var w = _ / 2 - d[c] / 2 + b;
        var E = oe(v, w, y);
        var A = l;
        i.modifiersData[n] = ((e = {})[A] = E, e.centerOffset = E - w, e);
      }
    },
    effect: function (t) {
      var e = t.state;
      var i = t.options.element;
      var n = i === undefined ? "[data-popper-arrow]" : i;
      if (n != null && (typeof n != "string" || (n = e.elements.popper.querySelector(n))) && Xt(e.elements.popper, n)) {
        e.elements.arrow = n;
      }
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function ce(t) {
    return t.split("-")[1];
  }
  var he = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function de(t) {
    var e;
    var i = t.popper;
    var n = t.popperRect;
    var s = t.placement;
    var o = t.variation;
    var r = t.offsets;
    var a = t.position;
    var l = t.gpuAcceleration;
    var c = t.adaptive;
    var h = t.roundOffsets;
    var d = h === true ? function (t) {
      var e = t.x;
      var i = t.y;
      var n = window.devicePixelRatio || 1;
      return {
        x: se(se(e * n) / n) || 0,
        y: se(se(i * n) / n) || 0
      };
    }(r) : typeof h == "function" ? h(r) : r;
    var u = d.x;
    var f = u === undefined ? 0 : u;
    var p = d.y;
    var m = p === undefined ? 0 : p;
    var g = r.hasOwnProperty("x");
    var _ = r.hasOwnProperty("y");
    var b = bt;
    var v = mt;
    var y = window;
    if (c) {
      var w = te(i);
      var E = "clientHeight";
      var A = "clientWidth";
      if (w === Wt(i) && Yt(w = Gt(i)).position !== "static" && a === "absolute") {
        E = "scrollHeight";
        A = "scrollWidth";
      }
      w = w;
      if (s === mt || (s === bt || s === _t) && o === Et) {
        v = gt;
        m -= w[E] - n.height;
        m *= l ? 1 : -1;
      }
      if (s === bt || (s === mt || s === gt) && o === Et) {
        b = _t;
        f -= w[A] - n.width;
        f *= l ? 1 : -1;
      }
    }
    var T;
    var O = Object.assign({
      position: a
    }, c && he);
    if (l) {
      return Object.assign({}, O, ((T = {})[v] = _ ? "0" : "", T[b] = g ? "0" : "", T.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", T));
    } else {
      return Object.assign({}, O, ((e = {})[v] = _ ? m + "px" : "", e[b] = g ? f + "px" : "", e.transform = "", e));
    }
  }
  const ue = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: function (t) {
      var e = t.state;
      var i = t.options;
      var n = i.gpuAcceleration;
      var s = n === undefined || n;
      var o = i.adaptive;
      var r = o === undefined || o;
      var a = i.roundOffsets;
      var l = a === undefined || a;
      var c = {
        placement: Ut(e.placement),
        variation: ce(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: s
      };
      if (e.modifiersData.popperOffsets != null) {
        e.styles.popper = Object.assign({}, e.styles.popper, de(Object.assign({}, c, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: r,
          roundOffsets: l
        })));
      }
      if (e.modifiersData.arrow != null) {
        e.styles.arrow = Object.assign({}, e.styles.arrow, de(Object.assign({}, c, {
          offsets: e.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets: l
        })));
      }
      e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    },
    data: {}
  };
  var fe = {
    passive: true
  };
  const pe = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function () {},
    effect: function (t) {
      var e = t.state;
      var i = t.instance;
      var n = t.options;
      var s = n.scroll;
      var o = s === undefined || s;
      var r = n.resize;
      var a = r === undefined || r;
      var l = Wt(e.elements.popper);
      var c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      if (o) {
        c.forEach(function (t) {
          t.addEventListener("scroll", i.update, fe);
        });
      }
      if (a) {
        l.addEventListener("resize", i.update, fe);
      }
      return function () {
        if (o) {
          c.forEach(function (t) {
            t.removeEventListener("scroll", i.update, fe);
          });
        }
        if (a) {
          l.removeEventListener("resize", i.update, fe);
        }
      };
    },
    data: {}
  };
  var me = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function ge(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return me[t];
    });
  }
  var _e = {
    start: "end",
    end: "start"
  };
  function be(t) {
    return t.replace(/start|end/g, function (t) {
      return _e[t];
    });
  }
  function ve(t) {
    var e = Wt(t);
    return {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    };
  }
  function ye(t) {
    return Vt(Gt(t)).left + ve(t).scrollLeft;
  }
  function we(t) {
    var e = Yt(t);
    var i = e.overflow;
    var n = e.overflowX;
    var s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n);
  }
  function Ee(t) {
    if (["html", "body", "#document"].indexOf(Rt(t)) >= 0) {
      return t.ownerDocument.body;
    } else if (zt(t) && we(t)) {
      return t;
    } else {
      return Ee(Zt(t));
    }
  }
  function Ae(t, e) {
    var i;
    if (e === undefined) {
      e = [];
    }
    var n = Ee(t);
    var s = n === ((i = t.ownerDocument) == null ? undefined : i.body);
    var o = Wt(n);
    var r = s ? [o].concat(o.visualViewport || [], we(n) ? n : []) : n;
    var a = e.concat(r);
    if (s) {
      return a;
    } else {
      return a.concat(Ae(Zt(r)));
    }
  }
  function Te(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  function Oe(t, e) {
    if (e === Tt) {
      return Te(function (t) {
        var e = Wt(t);
        var i = Gt(t);
        var n = e.visualViewport;
        var s = i.clientWidth;
        var o = i.clientHeight;
        var r = 0;
        var a = 0;
        if (n) {
          s = n.width;
          o = n.height;
          if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            r = n.offsetLeft;
            a = n.offsetTop;
          }
        }
        return {
          width: s,
          height: o,
          x: r + ye(t),
          y: a
        };
      }(t));
    } else if (zt(e)) {
      return function (t) {
        var e = Vt(t);
        e.top = e.top + t.clientTop;
        e.left = e.left + t.clientLeft;
        e.bottom = e.top + t.clientHeight;
        e.right = e.left + t.clientWidth;
        e.width = t.clientWidth;
        e.height = t.clientHeight;
        e.x = e.left;
        e.y = e.top;
        return e;
      }(e);
    } else {
      return Te(function (t) {
        var e;
        var i = Gt(t);
        var n = ve(t);
        var s = (e = t.ownerDocument) == null ? undefined : e.body;
        var o = ie(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0);
        var r = ie(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0);
        var a = -n.scrollLeft + ye(t);
        var l = -n.scrollTop;
        if (Yt(s || i).direction === "rtl") {
          a += ie(i.clientWidth, s ? s.clientWidth : 0) - o;
        }
        return {
          width: o,
          height: r,
          x: a,
          y: l
        };
      }(Gt(t)));
    }
  }
  function Ce(t) {
    var e;
    var i = t.reference;
    var n = t.element;
    var s = t.placement;
    var o = s ? Ut(s) : null;
    var r = s ? ce(s) : null;
    var a = i.x + i.width / 2 - n.width / 2;
    var l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
      case mt:
        e = {
          x: a,
          y: i.y - n.height
        };
        break;
      case gt:
        e = {
          x: a,
          y: i.y + i.height
        };
        break;
      case _t:
        e = {
          x: i.x + i.width,
          y: l
        };
        break;
      case bt:
        e = {
          x: i.x - n.width,
          y: l
        };
        break;
      default:
        e = {
          x: i.x,
          y: i.y
        };
    }
    var c = o ? ee(o) : null;
    if (c != null) {
      var h = c === "y" ? "height" : "width";
      switch (r) {
        case wt:
          e[c] = e[c] - (i[h] / 2 - n[h] / 2);
          break;
        case Et:
          e[c] = e[c] + (i[h] / 2 - n[h] / 2);
      }
    }
    return e;
  }
  function ke(t, e = {}) {
    var i = e;
    var n = i.placement;
    var s = n === undefined ? t.placement : n;
    var o = i.boundary;
    var r = o === undefined ? At : o;
    var a = i.rootBoundary;
    var l = a === undefined ? Tt : a;
    var c = i.elementContext;
    var h = c === undefined ? Ot : c;
    var d = i.altBoundary;
    var u = d !== undefined && d;
    var f = i.padding;
    var p = f === undefined ? 0 : f;
    var m = re(typeof p != "number" ? p : ae(p, yt));
    var g = h === Ot ? Ct : Ot;
    var _ = t.rects.popper;
    var b = t.elements[u ? g : h];
    var v = function (t, e, i) {
      var n = e === "clippingParents" ? function (t) {
        var e = Ae(Zt(t));
        var i = ["absolute", "fixed"].indexOf(Yt(t).position) >= 0 && zt(t) ? te(t) : t;
        if ($t(i)) {
          return e.filter(function (t) {
            return $t(t) && Xt(t, i) && Rt(t) !== "body";
          });
        } else {
          return [];
        }
      }(t) : [].concat(e);
      var s = [].concat(n, [i]);
      var o = s[0];
      var r = s.reduce(function (e, i) {
        var n = Oe(t, i);
        e.top = ie(n.top, e.top);
        e.right = ne(n.right, e.right);
        e.bottom = ne(n.bottom, e.bottom);
        e.left = ie(n.left, e.left);
        return e;
      }, Oe(t, o));
      r.width = r.right - r.left;
      r.height = r.bottom - r.top;
      r.x = r.left;
      r.y = r.top;
      return r;
    }($t(b) ? b : b.contextElement || Gt(t.elements.popper), r, l);
    var y = Vt(t.elements.reference);
    var w = Ce({
      reference: y,
      element: _,
      strategy: "absolute",
      placement: s
    });
    var E = Te(Object.assign({}, _, w));
    var A = h === Ot ? E : y;
    var T = {
      top: v.top - A.top + m.top,
      bottom: A.bottom - v.bottom + m.bottom,
      left: v.left - A.left + m.left,
      right: A.right - v.right + m.right
    };
    var O = t.modifiersData.offset;
    if (h === Ot && O) {
      var C = O[s];
      Object.keys(T).forEach(function (t) {
        var e = [_t, gt].indexOf(t) >= 0 ? 1 : -1;
        var i = [mt, gt].indexOf(t) >= 0 ? "y" : "x";
        T[t] += C[i] * e;
      });
    }
    return T;
  }
  function Le(t, e = {}) {
    var i = e;
    var n = i.placement;
    var s = i.boundary;
    var o = i.rootBoundary;
    var r = i.padding;
    var a = i.flipVariations;
    var l = i.allowedAutoPlacements;
    var c = l === undefined ? Lt : l;
    var h = ce(n);
    var d = h ? a ? kt : kt.filter(function (t) {
      return ce(t) === h;
    }) : yt;
    var u = d.filter(function (t) {
      return c.indexOf(t) >= 0;
    });
    if (u.length === 0) {
      u = d;
    }
    var f = u.reduce(function (e, i) {
      e[i] = ke(t, {
        placement: i,
        boundary: s,
        rootBoundary: o,
        padding: r
      })[Ut(i)];
      return e;
    }, {});
    return Object.keys(f).sort(function (t, e) {
      return f[t] - f[e];
    });
  }
  const xe = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: function (t) {
      var e = t.state;
      var i = t.options;
      var n = t.name;
      if (!e.modifiersData[n]._skip) {
        var s = i.mainAxis;
        var o = s === undefined || s;
        var r = i.altAxis;
        var a = r === undefined || r;
        var l = i.fallbackPlacements;
        var c = i.padding;
        var h = i.boundary;
        var d = i.rootBoundary;
        var u = i.altBoundary;
        var f = i.flipVariations;
        var p = f === undefined || f;
        var m = i.allowedAutoPlacements;
        var g = e.options.placement;
        var _ = Ut(g);
        var b = l || (_ !== g && p ? function (t) {
          if (Ut(t) === vt) {
            return [];
          }
          var e = ge(t);
          return [be(t), e, be(e)];
        }(g) : [ge(g)]);
        for (var v = [g].concat(b).reduce(function (t, i) {
            return t.concat(Ut(i) === vt ? Le(e, {
              placement: i,
              boundary: h,
              rootBoundary: d,
              padding: c,
              flipVariations: p,
              allowedAutoPlacements: m
            }) : i);
          }, []), y = e.rects.reference, w = e.rects.popper, E = new Map(), A = true, T = v[0], O = 0; O < v.length; O++) {
          var C = v[O];
          var k = Ut(C);
          var L = ce(C) === wt;
          var x = [mt, gt].indexOf(k) >= 0;
          var D = x ? "width" : "height";
          var S = ke(e, {
            placement: C,
            boundary: h,
            rootBoundary: d,
            altBoundary: u,
            padding: c
          });
          var N = x ? L ? _t : bt : L ? gt : mt;
          if (y[D] > w[D]) {
            N = ge(N);
          }
          var I = ge(N);
          var P = [];
          if (o) {
            P.push(S[k] <= 0);
          }
          if (a) {
            P.push(S[N] <= 0, S[I] <= 0);
          }
          if (P.every(function (t) {
            return t;
          })) {
            T = C;
            A = false;
            break;
          }
          E.set(C, P);
        }
        if (A) {
          for (var j = function (t) {
              var e = v.find(function (e) {
                var i = E.get(e);
                if (i) {
                  return i.slice(0, t).every(function (t) {
                    return t;
                  });
                }
              });
              if (e) {
                T = e;
                return "break";
              }
            }, M = p ? 3 : 1; M > 0 && j(M) !== "break"; M--);
        }
        if (e.placement !== T) {
          e.modifiersData[n]._skip = true;
          e.placement = T;
          e.reset = true;
        }
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function De(t, e, i = {
    x: 0,
    y: 0
  }) {
    return {
      top: t.top - e.height - i.y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    };
  }
  function Se(t) {
    return [mt, _t, gt, bt].some(function (e) {
      return t[e] >= 0;
    });
  }
  const Ne = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: function (t) {
      var e = t.state;
      var i = t.name;
      var n = e.rects.reference;
      var s = e.rects.popper;
      var o = e.modifiersData.preventOverflow;
      var r = ke(e, {
        elementContext: "reference"
      });
      var a = ke(e, {
        altBoundary: true
      });
      var l = De(r, n);
      var c = De(a, s, o);
      var h = Se(l);
      var d = Se(c);
      e.modifiersData[i] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: h,
        hasPopperEscaped: d
      };
      e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": h,
        "data-popper-escaped": d
      });
    }
  };
  const Ie = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: function (t) {
      var e = t.state;
      var i = t.options;
      var n = t.name;
      var s = i.offset;
      var o = s === undefined ? [0, 0] : s;
      var r = Lt.reduce(function (t, i) {
        t[i] = function (t, e, i) {
          var n = Ut(t);
          var s = [bt, mt].indexOf(n) >= 0 ? -1 : 1;
          var o = typeof i == "function" ? i(Object.assign({}, e, {
            placement: t
          })) : i;
          var r = o[0];
          var a = o[1];
          r = r || 0;
          a = (a || 0) * s;
          if ([bt, _t].indexOf(n) >= 0) {
            return {
              x: a,
              y: r
            };
          } else {
            return {
              x: r,
              y: a
            };
          }
        }(i, e.rects, o);
        return t;
      }, {});
      var a = r[e.placement];
      var l = a.x;
      var c = a.y;
      if (e.modifiersData.popperOffsets != null) {
        e.modifiersData.popperOffsets.x += l;
        e.modifiersData.popperOffsets.y += c;
      }
      e.modifiersData[n] = r;
    }
  };
  const Pe = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: function (t) {
      var e = t.state;
      var i = t.name;
      e.modifiersData[i] = Ce({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
      });
    },
    data: {}
  };
  const je = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: function (t) {
      var e = t.state;
      var i = t.options;
      var n = t.name;
      var s = i.mainAxis;
      var o = s === undefined || s;
      var r = i.altAxis;
      var a = r !== undefined && r;
      var l = i.boundary;
      var c = i.rootBoundary;
      var h = i.altBoundary;
      var d = i.padding;
      var u = i.tether;
      var f = u === undefined || u;
      var p = i.tetherOffset;
      var m = p === undefined ? 0 : p;
      var g = ke(e, {
        boundary: l,
        rootBoundary: c,
        padding: d,
        altBoundary: h
      });
      var _ = Ut(e.placement);
      var b = ce(e.placement);
      var v = !b;
      var y = ee(_);
      var w = y === "x" ? "y" : "x";
      var E = e.modifiersData.popperOffsets;
      var A = e.rects.reference;
      var T = e.rects.popper;
      var O = typeof m == "function" ? m(Object.assign({}, e.rects, {
        placement: e.placement
      })) : m;
      var C = {
        x: 0,
        y: 0
      };
      if (E) {
        if (o || a) {
          var k = y === "y" ? mt : bt;
          var L = y === "y" ? gt : _t;
          var x = y === "y" ? "height" : "width";
          var D = E[y];
          var S = E[y] + g[k];
          var N = E[y] - g[L];
          var I = f ? -T[x] / 2 : 0;
          var P = b === wt ? A[x] : T[x];
          var j = b === wt ? -T[x] : -A[x];
          var M = e.elements.arrow;
          var H = f && M ? Kt(M) : {
            width: 0,
            height: 0
          };
          var B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
          var R = B[k];
          var W = B[L];
          var $ = oe(0, A[x], H[x]);
          var z = v ? A[x] / 2 - I - $ - R - O : P - $ - R - O;
          var q = v ? -A[x] / 2 + I + $ + W + O : j + $ + W + O;
          var F = e.elements.arrow && te(e.elements.arrow);
          var U = F ? y === "y" ? F.clientTop || 0 : F.clientLeft || 0 : 0;
          var V = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0;
          var K = E[y] + z - V - U;
          var X = E[y] + q - V;
          if (o) {
            var Y = oe(f ? ne(S, K) : S, D, f ? ie(N, X) : N);
            E[y] = Y;
            C[y] = Y - D;
          }
          if (a) {
            var Q = y === "x" ? mt : bt;
            var G = y === "x" ? gt : _t;
            var Z = E[w];
            var J = Z + g[Q];
            var tt = Z - g[G];
            var et = oe(f ? ne(J, K) : J, Z, f ? ie(tt, X) : tt);
            E[w] = et;
            C[w] = et - Z;
          }
        }
        e.modifiersData[n] = C;
      }
    },
    requiresIfExists: ["offset"]
  };
  function Me(t, e, i = false) {
    var n = zt(e);
    if (zt(e)) {
      (function (t) {
        var e = t.getBoundingClientRect();
        e.width;
        t.offsetWidth;
        e.height;
        t.offsetHeight;
      })(e);
    }
    var s;
    var o;
    var r = Gt(e);
    var a = Vt(t);
    var l = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var c = {
      x: 0,
      y: 0
    };
    if (n || !n && !i) {
      if (Rt(e) !== "body" || we(r)) {
        l = (s = e) !== Wt(s) && zt(s) ? {
          scrollLeft: (o = s).scrollLeft,
          scrollTop: o.scrollTop
        } : ve(s);
      }
      if (zt(e)) {
        (c = Vt(e)).x += e.clientLeft;
        c.y += e.clientTop;
      } else if (r) {
        c.x = ye(r);
      }
    }
    return {
      x: a.left + l.scrollLeft - c.x,
      y: a.top + l.scrollTop - c.y,
      width: a.width,
      height: a.height
    };
  }
  function He(t) {
    var e = new Map();
    var i = new Set();
    var n = [];
    function s(t) {
      i.add(t.name);
      [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) {
        if (!i.has(t)) {
          var n = e.get(t);
          if (n) {
            s(n);
          }
        }
      });
      n.push(t);
    }
    t.forEach(function (t) {
      e.set(t.name, t);
    });
    t.forEach(function (t) {
      if (!i.has(t.name)) {
        s(t);
      }
    });
    return n;
  }
  var Be = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Re() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) {
      e[i] = arguments[i];
    }
    return !e.some(function (t) {
      return !t || typeof t.getBoundingClientRect != "function";
    });
  }
  function We(t = {}) {
    var e = t;
    var i = e.defaultModifiers;
    var n = i === undefined ? [] : i;
    var s = e.defaultOptions;
    var o = s === undefined ? Be : s;
    return function (t, e, i = o) {
      var s;
      var r;
      var a = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Be, o),
        modifiersData: {},
        elements: {
          reference: t,
          popper: e
        },
        attributes: {},
        styles: {}
      };
      var l = [];
      var c = false;
      var h = {
        state: a,
        setOptions: function (i) {
          var s = typeof i == "function" ? i(a.options) : i;
          d();
          a.options = Object.assign({}, o, a.options, s);
          a.scrollParents = {
            reference: $t(t) ? Ae(t) : t.contextElement ? Ae(t.contextElement) : [],
            popper: Ae(e)
          };
          var r;
          var c;
          var u = function (t) {
            var e = He(t);
            return Bt.reduce(function (t, i) {
              return t.concat(e.filter(function (t) {
                return t.phase === i;
              }));
            }, []);
          }((r = [].concat(n, a.options.modifiers), c = r.reduce(function (t, e) {
            var i = t[e.name];
            t[e.name] = i ? Object.assign({}, i, e, {
              options: Object.assign({}, i.options, e.options),
              data: Object.assign({}, i.data, e.data)
            }) : e;
            return t;
          }, {}), Object.keys(c).map(function (t) {
            return c[t];
          })));
          a.orderedModifiers = u.filter(function (t) {
            return t.enabled;
          });
          a.orderedModifiers.forEach(function (t) {
            var e = t.name;
            var i = t.options;
            var n = i === undefined ? {} : i;
            var s = t.effect;
            if (typeof s == "function") {
              var o = s({
                state: a,
                name: e,
                instance: h,
                options: n
              });
              l.push(o || function () {});
            }
          });
          return h.update();
        },
        forceUpdate: function () {
          if (!c) {
            var t = a.elements;
            var e = t.reference;
            var i = t.popper;
            if (Re(e, i)) {
              a.rects = {
                reference: Me(e, te(i), a.options.strategy === "fixed"),
                popper: Kt(i)
              };
              a.reset = false;
              a.placement = a.options.placement;
              a.orderedModifiers.forEach(function (t) {
                return a.modifiersData[t.name] = Object.assign({}, t.data);
              });
              for (var n = 0; n < a.orderedModifiers.length; n++) {
                if (a.reset !== true) {
                  var s = a.orderedModifiers[n];
                  var o = s.fn;
                  var r = s.options;
                  var l = r === undefined ? {} : r;
                  var d = s.name;
                  if (typeof o == "function") {
                    a = o({
                      state: a,
                      options: l,
                      name: d,
                      instance: h
                    }) || a;
                  }
                } else {
                  a.reset = false;
                  n = -1;
                }
              }
            }
          }
        },
        update: (s = function () {
          return new Promise(function (t) {
            h.forceUpdate();
            t(a);
          });
        }, function () {
          r ||= new Promise(function (t) {
            Promise.resolve().then(function () {
              r = undefined;
              t(s());
            });
          });
          return r;
        }),
        destroy: function () {
          d();
          c = true;
        }
      };
      if (!Re(t, e)) {
        return h;
      }
      function d() {
        l.forEach(function (t) {
          return t();
        });
        l = [];
      }
      h.setOptions(i).then(function (t) {
        if (!c && i.onFirstUpdate) {
          i.onFirstUpdate(t);
        }
      });
      return h;
    };
  }
  var $e = We();
  var ze = We({
    defaultModifiers: [pe, Pe, ue, Ft]
  });
  var qe = We({
    defaultModifiers: [pe, Pe, ue, Ft, Ie, xe, je, le, Ne]
  });
  const Fe = Object.freeze({
    __proto__: null,
    popperGenerator: We,
    detectOverflow: ke,
    createPopperBase: $e,
    createPopper: qe,
    createPopperLite: ze,
    top: mt,
    bottom: gt,
    right: _t,
    left: bt,
    auto: vt,
    basePlacements: yt,
    start: wt,
    end: Et,
    clippingParents: At,
    viewport: Tt,
    popper: Ot,
    reference: Ct,
    variationPlacements: kt,
    placements: Lt,
    beforeRead: xt,
    read: Dt,
    afterRead: St,
    beforeMain: Nt,
    main: It,
    afterMain: Pt,
    beforeWrite: jt,
    write: Mt,
    afterWrite: Ht,
    modifierPhases: Bt,
    applyStyles: Ft,
    arrow: le,
    computeStyles: ue,
    eventListeners: pe,
    flip: xe,
    hide: Ne,
    offset: Ie,
    popperOffsets: Pe,
    preventOverflow: je
  });
  const Ue = "dropdown";
  const Ve = "Escape";
  const Ke = "Space";
  const Xe = "ArrowUp";
  const Ye = "ArrowDown";
  const Qe = new RegExp("ArrowUp|ArrowDown|Escape");
  const Ge = "click.bs.dropdown.data-api";
  const Ze = "keydown.bs.dropdown.data-api";
  const Je = "show";
  const ti = "[data-bs-toggle=\"dropdown\"]";
  const ei = ".dropdown-menu";
  const ii = m() ? "top-end" : "top-start";
  const ni = m() ? "top-start" : "top-end";
  const si = m() ? "bottom-end" : "bottom-start";
  const oi = m() ? "bottom-start" : "bottom-end";
  const ri = m() ? "left-start" : "right-start";
  const ai = m() ? "right-start" : "left-start";
  const li = {
    offset: [0, 2],
    boundary: "clippingParents",
    reference: "toggle",
    display: "dynamic",
    popperConfig: null,
    autoClose: true
  };
  const ci = {
    offset: "(array|string|function)",
    boundary: "(string|element)",
    reference: "(string|element|object)",
    display: "string",
    popperConfig: "(null|object|function)",
    autoClose: "(boolean|string)"
  };
  class hi extends B {
    constructor(t, e) {
      super(t);
      this._popper = null;
      this._config = this._getConfig(e);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();
    }
    static get Default() {
      return li;
    }
    static get DefaultType() {
      return ci;
    }
    static get NAME() {
      return Ue;
    }
    toggle() {
      if (this._isShown()) {
        return this.hide();
      } else {
        return this.show();
      }
    }
    show() {
      if (c(this._element) || this._isShown(this._menu)) {
        return;
      }
      const t = {
        relatedTarget: this._element
      };
      if (j.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
        return;
      }
      const e = hi.getParentFromElement(this._element);
      if (this._inNavbar) {
        U.setDataAttribute(this._menu, "popper", "none");
      } else {
        this._createPopper(e);
      }
      if ("ontouchstart" in document.documentElement && !e.closest(".navbar-nav")) {
        [].concat(...document.body.children).forEach(t => j.on(t, "mouseover", d));
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(Je);
      this._element.classList.add(Je);
      j.trigger(this._element, "shown.bs.dropdown", t);
    }
    hide() {
      if (c(this._element) || !this._isShown(this._menu)) {
        return;
      }
      const t = {
        relatedTarget: this._element
      };
      this._completeHide(t);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    _completeHide(t) {
      if (!j.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement) {
          [].concat(...document.body.children).forEach(t => j.off(t, "mouseover", d));
        }
        if (this._popper) {
          this._popper.destroy();
        }
        this._menu.classList.remove(Je);
        this._element.classList.remove(Je);
        this._element.setAttribute("aria-expanded", "false");
        U.removeDataAttribute(this._menu, "popper");
        j.trigger(this._element, "hidden.bs.dropdown", t);
      }
    }
    _getConfig(t) {
      t = {
        ...this.constructor.Default,
        ...U.getDataAttributes(this._element),
        ...t
      };
      a(Ue, t, this.constructor.DefaultType);
      if (typeof t.reference == "object" && !o(t.reference) && typeof t.reference.getBoundingClientRect != "function") {
        throw new TypeError(`${Ue.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return t;
    }
    _createPopper(t) {
      if (Fe === undefined) {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let e = this._element;
      if (this._config.reference === "parent") {
        e = t;
      } else if (o(this._config.reference)) {
        e = r(this._config.reference);
      } else if (typeof this._config.reference == "object") {
        e = this._config.reference;
      }
      const i = this._getPopperConfig();
      const n = i.modifiers.find(t => t.name === "applyStyles" && t.enabled === false);
      this._popper = qe(e, this._menu, i);
      if (n) {
        U.setDataAttribute(this._menu, "popper", "static");
      }
    }
    _isShown(t = this._element) {
      return t.classList.contains(Je);
    }
    _getMenuElement() {
      return V.next(this._element, ei)[0];
    }
    _getPlacement() {
      const t = this._element.parentNode;
      if (t.classList.contains("dropend")) {
        return ri;
      }
      if (t.classList.contains("dropstart")) {
        return ai;
      }
      const e = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (t.classList.contains("dropup")) {
        if (e) {
          return ni;
        } else {
          return ii;
        }
      } else if (e) {
        return oi;
      } else {
        return si;
      }
    }
    _detectNavbar() {
      return this._element.closest(".navbar") !== null;
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      if (typeof t == "string") {
        return t.split(",").map(t => Number.parseInt(t, 10));
      } else if (typeof t == "function") {
        return e => t(e, this._element);
      } else {
        return t;
      }
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._config.display === "static") {
        t.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...t,
        ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig)
      };
    }
    _selectMenuItem({
      key: t,
      target: e
    }) {
      const i = V.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(l);
      if (i.length) {
        v(i, e, t === Ye, !i.includes(e)).focus();
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = hi.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t]();
        }
      });
    }
    static clearMenus(t) {
      if (t && (t.button === 2 || t.type === "keyup" && t.key !== "Tab")) {
        return;
      }
      const e = V.find(ti);
      for (let i = 0, n = e.length; i < n; i++) {
        const n = hi.getInstance(e[i]);
        if (!n || n._config.autoClose === false) {
          continue;
        }
        if (!n._isShown()) {
          continue;
        }
        const s = {
          relatedTarget: n._element
        };
        if (t) {
          const e = t.composedPath();
          const i = e.includes(n._menu);
          if (e.includes(n._element) || n._config.autoClose === "inside" && !i || n._config.autoClose === "outside" && i) {
            continue;
          }
          if (n._menu.contains(t.target) && (t.type === "keyup" && t.key === "Tab" || /input|select|option|textarea|form/i.test(t.target.tagName))) {
            continue;
          }
          if (t.type === "click") {
            s.clickEvent = t;
          }
        }
        n._completeHide(s);
      }
    }
    static getParentFromElement(t) {
      return n(t) || t.parentNode;
    }
    static dataApiKeydownHandler(t) {
      if (/input|textarea/i.test(t.target.tagName) ? t.key === Ke || t.key !== Ve && (t.key !== Ye && t.key !== Xe || t.target.closest(ei)) : !Qe.test(t.key)) {
        return;
      }
      const e = this.classList.contains(Je);
      if (!e && t.key === Ve) {
        return;
      }
      t.preventDefault();
      t.stopPropagation();
      if (c(this)) {
        return;
      }
      const i = this.matches(ti) ? this : V.prev(this, ti)[0];
      const n = hi.getOrCreateInstance(i);
      if (t.key !== Ve) {
        if (t.key === Xe || t.key === Ye) {
          if (!e) {
            n.show();
          }
          n._selectMenuItem(t);
          return;
        } else {
          if (!e || t.key === Ke) {
            hi.clearMenus();
          }
          return;
        }
      }
      n.hide();
    }
  }
  j.on(document, Ze, ti, hi.dataApiKeydownHandler);
  j.on(document, Ze, ei, hi.dataApiKeydownHandler);
  j.on(document, Ge, hi.clearMenus);
  j.on(document, "keyup.bs.dropdown.data-api", hi.clearMenus);
  j.on(document, Ge, ti, function (t) {
    t.preventDefault();
    hi.getOrCreateInstance(this).toggle();
  });
  g(hi);
  const di = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  const ui = ".sticky-top";
  class fi {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      const t = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, "paddingRight", e => e + t);
      this._setElementAttributes(di, "paddingRight", e => e + t);
      this._setElementAttributes(ui, "marginRight", e => e - t);
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(t, e, i) {
      const n = this.getWidth();
      this._applyManipulationCallback(t, t => {
        if (t !== this._element && window.innerWidth > t.clientWidth + n) {
          return;
        }
        this._saveInitialAttribute(t, e);
        const s = window.getComputedStyle(t)[e];
        t.style[e] = `${i(Number.parseFloat(s))}px`;
      });
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, "paddingRight");
      this._resetElementAttributes(di, "paddingRight");
      this._resetElementAttributes(ui, "marginRight");
    }
    _saveInitialAttribute(t, e) {
      const i = t.style[e];
      if (i) {
        U.setDataAttribute(t, e, i);
      }
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, t => {
        const i = U.getDataAttribute(t, e);
        if (i === undefined) {
          t.style.removeProperty(e);
        } else {
          U.removeDataAttribute(t, e);
          t.style[e] = i;
        }
      });
    }
    _applyManipulationCallback(t, e) {
      if (o(t)) {
        e(t);
      } else {
        V.find(t, this._element).forEach(e);
      }
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
  }
  const pi = {
    className: "modal-backdrop",
    isVisible: true,
    isAnimated: false,
    rootElement: "body",
    clickCallback: null
  };
  const mi = {
    className: "string",
    isVisible: "boolean",
    isAnimated: "boolean",
    rootElement: "(element|string)",
    clickCallback: "(function|null)"
  };
  const gi = "show";
  const _i = "mousedown.bs.backdrop";
  class bi {
    constructor(t) {
      this._config = this._getConfig(t);
      this._isAppended = false;
      this._element = null;
    }
    show(t) {
      if (this._config.isVisible) {
        this._append();
        if (this._config.isAnimated) {
          u(this._getElement());
        }
        this._getElement().classList.add(gi);
        this._emulateAnimation(() => {
          _(t);
        });
      } else {
        _(t);
      }
    }
    hide(t) {
      if (this._config.isVisible) {
        this._getElement().classList.remove(gi);
        this._emulateAnimation(() => {
          this.dispose();
          _(t);
        });
      } else {
        _(t);
      }
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className;
        if (this._config.isAnimated) {
          t.classList.add("fade");
        }
        this._element = t;
      }
      return this._element;
    }
    _getConfig(t) {
      (t = {
        ...pi,
        ...(typeof t == "object" ? t : {})
      }).rootElement = r(t.rootElement);
      a("backdrop", t, mi);
      return t;
    }
    _append() {
      if (!this._isAppended) {
        this._config.rootElement.append(this._getElement());
        j.on(this._getElement(), _i, () => {
          _(this._config.clickCallback);
        });
        this._isAppended = true;
      }
    }
    dispose() {
      if (this._isAppended) {
        j.off(this._element, _i);
        this._element.remove();
        this._isAppended = false;
      }
    }
    _emulateAnimation(t) {
      b(t, this._getElement(), this._config.isAnimated);
    }
  }
  const vi = {
    trapElement: null,
    autofocus: true
  };
  const yi = {
    trapElement: "element",
    autofocus: "boolean"
  };
  const wi = ".bs.focustrap";
  const Ei = "backward";
  class Ai {
    constructor(t) {
      this._config = this._getConfig(t);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    activate() {
      const {
        trapElement: t,
        autofocus: e
      } = this._config;
      if (!this._isActive) {
        if (e) {
          t.focus();
        }
        j.off(document, wi);
        j.on(document, "focusin.bs.focustrap", t => this._handleFocusin(t));
        j.on(document, "keydown.tab.bs.focustrap", t => this._handleKeydown(t));
        this._isActive = true;
      }
    }
    deactivate() {
      if (this._isActive) {
        this._isActive = false;
        j.off(document, wi);
      }
    }
    _handleFocusin(t) {
      const {
        target: e
      } = t;
      const {
        trapElement: i
      } = this._config;
      if (e === document || e === i || i.contains(e)) {
        return;
      }
      const n = V.focusableChildren(i);
      if (n.length === 0) {
        i.focus();
      } else if (this._lastTabNavDirection === Ei) {
        n[n.length - 1].focus();
      } else {
        n[0].focus();
      }
    }
    _handleKeydown(t) {
      if (t.key === "Tab") {
        this._lastTabNavDirection = t.shiftKey ? Ei : "forward";
      }
    }
    _getConfig(t) {
      t = {
        ...vi,
        ...(typeof t == "object" ? t : {})
      };
      a("focustrap", t, yi);
      return t;
    }
  }
  const Ti = "modal";
  const Oi = "Escape";
  const Ci = {
    backdrop: true,
    keyboard: true,
    focus: true
  };
  const ki = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean"
  };
  const Li = "hidden.bs.modal";
  const xi = "show.bs.modal";
  const Di = "resize.bs.modal";
  const Si = "click.dismiss.bs.modal";
  const Ni = "keydown.dismiss.bs.modal";
  const Ii = "mousedown.dismiss.bs.modal";
  const Pi = "modal-open";
  const ji = "show";
  const Mi = "modal-static";
  class Hi extends B {
    constructor(t, e) {
      super(t);
      this._config = this._getConfig(e);
      this._dialog = V.findOne(".modal-dialog", this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollBar = new fi();
    }
    static get Default() {
      return Ci;
    }
    static get NAME() {
      return Ti;
    }
    toggle(t) {
      if (this._isShown) {
        return this.hide();
      } else {
        return this.show(t);
      }
    }
    show(t) {
      if (!this._isShown && !this._isTransitioning && !j.trigger(this._element, xi, {
        relatedTarget: t
      }).defaultPrevented) {
        this._isShown = true;
        if (this._isAnimated()) {
          this._isTransitioning = true;
        }
        this._scrollBar.hide();
        document.body.classList.add(Pi);
        this._adjustDialog();
        this._setEscapeEvent();
        this._setResizeEvent();
        j.on(this._dialog, Ii, () => {
          j.one(this._element, "mouseup.dismiss.bs.modal", t => {
            if (t.target === this._element) {
              this._ignoreBackdropClick = true;
            }
          });
        });
        this._showBackdrop(() => this._showElement(t));
      }
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      if (j.trigger(this._element, "hide.bs.modal").defaultPrevented) {
        return;
      }
      this._isShown = false;
      const t = this._isAnimated();
      if (t) {
        this._isTransitioning = true;
      }
      this._setEscapeEvent();
      this._setResizeEvent();
      this._focustrap.deactivate();
      this._element.classList.remove(ji);
      j.off(this._element, Si);
      j.off(this._dialog, Ii);
      this._queueCallback(() => this._hideModal(), this._element, t);
    }
    dispose() {
      [window, this._dialog].forEach(t => j.off(t, ".bs.modal"));
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new bi({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new Ai({
        trapElement: this._element
      });
    }
    _getConfig(t) {
      t = {
        ...Ci,
        ...U.getDataAttributes(this._element),
        ...(typeof t == "object" ? t : {})
      };
      a(Ti, t, ki);
      return t;
    }
    _showElement(t) {
      const e = this._isAnimated();
      const i = V.findOne(".modal-body", this._dialog);
      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      if (i) {
        i.scrollTop = 0;
      }
      if (e) {
        u(this._element);
      }
      this._element.classList.add(ji);
      this._queueCallback(() => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        j.trigger(this._element, "shown.bs.modal", {
          relatedTarget: t
        });
      }, this._dialog, e);
    }
    _setEscapeEvent() {
      if (this._isShown) {
        j.on(this._element, Ni, t => {
          if (this._config.keyboard && t.key === Oi) {
            t.preventDefault();
            this.hide();
          } else if (!this._config.keyboard && t.key === Oi) {
            this._triggerBackdropTransition();
          }
        });
      } else {
        j.off(this._element, Ni);
      }
    }
    _setResizeEvent() {
      if (this._isShown) {
        j.on(window, Di, () => this._adjustDialog());
      } else {
        j.off(window, Di);
      }
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(Pi);
        this._resetAdjustments();
        this._scrollBar.reset();
        j.trigger(this._element, Li);
      });
    }
    _showBackdrop(t) {
      j.on(this._element, Si, t => {
        if (this._ignoreBackdropClick) {
          this._ignoreBackdropClick = false;
        } else if (t.target === t.currentTarget) {
          if (this._config.backdrop === true) {
            this.hide();
          } else if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
          }
        }
      });
      this._backdrop.show(t);
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (j.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
        return;
      }
      const {
        classList: t,
        scrollHeight: e,
        style: i
      } = this._element;
      const n = e > document.documentElement.clientHeight;
      if ((!!n || i.overflowY !== "hidden") && !t.contains(Mi)) {
        if (!n) {
          i.overflowY = "hidden";
        }
        t.add(Mi);
        this._queueCallback(() => {
          t.remove(Mi);
          if (!n) {
            this._queueCallback(() => {
              i.overflowY = "";
            }, this._dialog);
          }
        }, this._dialog);
        this._element.focus();
      }
    }
    _adjustDialog() {
      const t = this._element.scrollHeight > document.documentElement.clientHeight;
      const e = this._scrollBar.getWidth();
      const i = e > 0;
      if (!i && t && !m() || i && !t && m()) {
        this._element.style.paddingLeft = `${e}px`;
      }
      if (i && !t && !m() || !i && t && m()) {
        this._element.style.paddingRight = `${e}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        const i = Hi.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (i[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          i[t](e);
        }
      });
    }
  }
  j.on(document, "click.bs.modal.data-api", "[data-bs-toggle=\"modal\"]", function (t) {
    const e = n(this);
    if (["A", "AREA"].includes(this.tagName)) {
      t.preventDefault();
    }
    j.one(e, xi, t => {
      if (!t.defaultPrevented) {
        j.one(e, Li, () => {
          if (l(this)) {
            this.focus();
          }
        });
      }
    });
    const i = V.findOne(".modal.show");
    if (i) {
      Hi.getInstance(i).hide();
    }
    Hi.getOrCreateInstance(e).toggle(this);
  });
  R(Hi);
  g(Hi);
  const Bi = "offcanvas";
  const Ri = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  const Wi = {
    backdrop: "boolean",
    keyboard: "boolean",
    scroll: "boolean"
  };
  const $i = "show";
  const zi = ".offcanvas.show";
  const qi = "hidden.bs.offcanvas";
  class Fi extends B {
    constructor(t, e) {
      super(t);
      this._config = this._getConfig(e);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    static get NAME() {
      return Bi;
    }
    static get Default() {
      return Ri;
    }
    toggle(t) {
      if (this._isShown) {
        return this.hide();
      } else {
        return this.show(t);
      }
    }
    show(t) {
      if (!this._isShown && !j.trigger(this._element, "show.bs.offcanvas", {
        relatedTarget: t
      }).defaultPrevented) {
        this._isShown = true;
        this._element.style.visibility = "visible";
        this._backdrop.show();
        if (!this._config.scroll) {
          new fi().hide();
        }
        this._element.removeAttribute("aria-hidden");
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        this._element.classList.add($i);
        this._queueCallback(() => {
          if (!this._config.scroll) {
            this._focustrap.activate();
          }
          j.trigger(this._element, "shown.bs.offcanvas", {
            relatedTarget: t
          });
        }, this._element, true);
      }
    }
    hide() {
      if (this._isShown) {
        if (!j.trigger(this._element, "hide.bs.offcanvas").defaultPrevented) {
          this._focustrap.deactivate();
          this._element.blur();
          this._isShown = false;
          this._element.classList.remove($i);
          this._backdrop.hide();
          this._queueCallback(() => {
            this._element.setAttribute("aria-hidden", true);
            this._element.removeAttribute("aria-modal");
            this._element.removeAttribute("role");
            this._element.style.visibility = "hidden";
            if (!this._config.scroll) {
              new fi().reset();
            }
            j.trigger(this._element, qi);
          }, this._element, true);
        }
      }
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    _getConfig(t) {
      t = {
        ...Ri,
        ...U.getDataAttributes(this._element),
        ...(typeof t == "object" ? t : {})
      };
      a(Bi, t, Wi);
      return t;
    }
    _initializeBackDrop() {
      return new bi({
        className: "offcanvas-backdrop",
        isVisible: this._config.backdrop,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide()
      });
    }
    _initializeFocusTrap() {
      return new Ai({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      j.on(this._element, "keydown.dismiss.bs.offcanvas", t => {
        if (this._config.keyboard && t.key === "Escape") {
          this.hide();
        }
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Fi.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined || t.startsWith("_") || t === "constructor") {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t](this);
        }
      });
    }
  }
  j.on(document, "click.bs.offcanvas.data-api", "[data-bs-toggle=\"offcanvas\"]", function (t) {
    const e = n(this);
    if (["A", "AREA"].includes(this.tagName)) {
      t.preventDefault();
    }
    if (c(this)) {
      return;
    }
    j.one(e, qi, () => {
      if (l(this)) {
        this.focus();
      }
    });
    const i = V.findOne(zi);
    if (i && i !== e) {
      Fi.getInstance(i).hide();
    }
    Fi.getOrCreateInstance(e).toggle(this);
  });
  j.on(window, "load.bs.offcanvas.data-api", () => V.find(zi).forEach(t => Fi.getOrCreateInstance(t).show()));
  R(Fi);
  g(Fi);
  const Ui = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  const Vi = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  const Ki = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  const Xi = (t, e) => {
    const i = t.nodeName.toLowerCase();
    if (e.includes(i)) {
      return !Ui.has(i) || Boolean(Vi.test(t.nodeValue) || Ki.test(t.nodeValue));
    }
    const n = e.filter(t => t instanceof RegExp);
    for (let t = 0, e = n.length; t < e; t++) {
      if (n[t].test(i)) {
        return true;
      }
    }
    return false;
  };
  function Yi(t, e, i) {
    if (!t.length) {
      return t;
    }
    if (i && typeof i == "function") {
      return i(t);
    }
    const n = new window.DOMParser().parseFromString(t, "text/html");
    const s = [].concat(...n.body.querySelectorAll("*"));
    for (let t = 0, i = s.length; t < i; t++) {
      const i = s[t];
      const n = i.nodeName.toLowerCase();
      if (!Object.keys(e).includes(n)) {
        i.remove();
        continue;
      }
      const o = [].concat(...i.attributes);
      const r = [].concat(e["*"] || [], e[n] || []);
      o.forEach(t => {
        if (!Xi(t, r)) {
          i.removeAttribute(t.nodeName);
        }
      });
    }
    return n.body.innerHTML;
  }
  const Qi = "tooltip";
  const Gi = new Set(["sanitize", "allowList", "sanitizeFn"]);
  const Zi = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(array|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacements: "array",
    boundary: "(string|element)",
    customClass: "(string|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    allowList: "object",
    popperConfig: "(null|object|function)"
  };
  const Ji = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: m() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: m() ? "right" : "left"
  };
  const tn = {
    animation: true,
    template: "<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>",
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: false,
    selector: false,
    placement: "top",
    offset: [0, 0],
    container: false,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: true,
    sanitizeFn: null,
    allowList: {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    },
    popperConfig: null
  };
  const en = {
    HIDE: "hide.bs.tooltip",
    HIDDEN: "hidden.bs.tooltip",
    SHOW: "show.bs.tooltip",
    SHOWN: "shown.bs.tooltip",
    INSERTED: "inserted.bs.tooltip",
    CLICK: "click.bs.tooltip",
    FOCUSIN: "focusin.bs.tooltip",
    FOCUSOUT: "focusout.bs.tooltip",
    MOUSEENTER: "mouseenter.bs.tooltip",
    MOUSELEAVE: "mouseleave.bs.tooltip"
  };
  const nn = "fade";
  const sn = "show";
  const on = "show";
  const rn = "out";
  const an = ".tooltip-inner";
  const ln = ".modal";
  const cn = "hide.bs.modal";
  const hn = "hover";
  const dn = "focus";
  class un extends B {
    constructor(t, e) {
      if (Fe === undefined) {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      }
      super(t);
      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = "";
      this._activeTrigger = {};
      this._popper = null;
      this._config = this._getConfig(e);
      this.tip = null;
      this._setListeners();
    }
    static get Default() {
      return tn;
    }
    static get NAME() {
      return Qi;
    }
    static get Event() {
      return en;
    }
    static get DefaultType() {
      return Zi;
    }
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(t) {
      if (this._isEnabled) {
        if (t) {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger.click = !e._activeTrigger.click;
          if (e._isWithActiveTrigger()) {
            e._enter(null, e);
          } else {
            e._leave(null, e);
          }
        } else {
          if (this.getTipElement().classList.contains(sn)) {
            this._leave(null, this);
            return;
          }
          this._enter(null, this);
        }
      }
    }
    dispose() {
      clearTimeout(this._timeout);
      j.off(this._element.closest(ln), cn, this._hideModalHandler);
      if (this.tip) {
        this.tip.remove();
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!this.isWithContent() || !this._isEnabled) {
        return;
      }
      const t = j.trigger(this._element, this.constructor.Event.SHOW);
      const e = h(this._element);
      const i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
      if (t.defaultPrevented || !i) {
        return;
      }
      if (this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(an).innerHTML) {
        this._disposePopper();
        this.tip.remove();
        this.tip = null;
      }
      const n = this.getTipElement();
      const s = (t => {
        do {
          t += Math.floor(Math.random() * 1000000);
        } while (document.getElementById(t));
        return t;
      })(this.constructor.NAME);
      n.setAttribute("id", s);
      this._element.setAttribute("aria-describedby", s);
      if (this._config.animation) {
        n.classList.add(nn);
      }
      const o = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement;
      const r = this._getAttachment(o);
      this._addAttachmentClass(r);
      const {
        container: a
      } = this._config;
      H.set(n, this.constructor.DATA_KEY, this);
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        a.append(n);
        j.trigger(this._element, this.constructor.Event.INSERTED);
      }
      if (this._popper) {
        this._popper.update();
      } else {
        this._popper = qe(this._element, n, this._getPopperConfig(r));
      }
      n.classList.add(sn);
      const l = this._resolvePossibleFunction(this._config.customClass);
      if (l) {
        n.classList.add(...l.split(" "));
      }
      if ("ontouchstart" in document.documentElement) {
        [].concat(...document.body.children).forEach(t => {
          j.on(t, "mouseover", d);
        });
      }
      const c = this.tip.classList.contains(nn);
      this._queueCallback(() => {
        const t = this._hoverState;
        this._hoverState = null;
        j.trigger(this._element, this.constructor.Event.SHOWN);
        if (t === rn) {
          this._leave(null, this);
        }
      }, this.tip, c);
    }
    hide() {
      if (!this._popper) {
        return;
      }
      const t = this.getTipElement();
      if (j.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {
        return;
      }
      t.classList.remove(sn);
      if ("ontouchstart" in document.documentElement) {
        [].concat(...document.body.children).forEach(t => j.off(t, "mouseover", d));
      }
      this._activeTrigger.click = false;
      this._activeTrigger.focus = false;
      this._activeTrigger.hover = false;
      const e = this.tip.classList.contains(nn);
      this._queueCallback(() => {
        if (!this._isWithActiveTrigger()) {
          if (this._hoverState !== on) {
            t.remove();
          }
          this._cleanTipClass();
          this._element.removeAttribute("aria-describedby");
          j.trigger(this._element, this.constructor.Event.HIDDEN);
          this._disposePopper();
        }
      }, this.tip, e);
      this._hoverState = "";
    }
    update() {
      if (this._popper !== null) {
        this._popper.update();
      }
    }
    isWithContent() {
      return Boolean(this.getTitle());
    }
    getTipElement() {
      if (this.tip) {
        return this.tip;
      }
      const t = document.createElement("div");
      t.innerHTML = this._config.template;
      const e = t.children[0];
      this.setContent(e);
      e.classList.remove(nn, sn);
      this.tip = e;
      return this.tip;
    }
    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), an);
    }
    _sanitizeAndSetContent(t, e, i) {
      const n = V.findOne(i, t);
      if (e || !n) {
        this.setElementContent(n, e);
      } else {
        n.remove();
      }
    }
    setElementContent(t, e) {
      if (t !== null) {
        if (o(e)) {
          e = r(e);
          if (this._config.html) {
            if (e.parentNode !== t) {
              t.innerHTML = "";
              t.append(e);
            }
          } else {
            t.textContent = e.textContent;
          }
          return;
        } else {
          if (this._config.html) {
            if (this._config.sanitize) {
              e = Yi(e, this._config.allowList, this._config.sanitizeFn);
            }
            t.innerHTML = e;
          } else {
            t.textContent = e;
          }
          return;
        }
      }
    }
    getTitle() {
      const t = this._element.getAttribute("data-bs-original-title") || this._config.title;
      return this._resolvePossibleFunction(t);
    }
    updateAttachment(t) {
      if (t === "right") {
        return "end";
      } else if (t === "left") {
        return "start";
      } else {
        return t;
      }
    }
    _initializeOnDelegatedTarget(t, e) {
      return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      if (typeof t == "string") {
        return t.split(",").map(t => Number.parseInt(t, 10));
      } else if (typeof t == "function") {
        return e => t(e, this._element);
      } else {
        return t;
      }
    }
    _resolvePossibleFunction(t) {
      if (typeof t == "function") {
        return t.call(this._element);
      } else {
        return t;
      }
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "onChange",
          enabled: true,
          phase: "afterWrite",
          fn: t => this._handlePopperPlacementChange(t)
        }],
        onFirstUpdate: t => {
          if (t.options.placement !== t.placement) {
            this._handlePopperPlacementChange(t);
          }
        }
      };
      return {
        ...e,
        ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig)
      };
    }
    _addAttachmentClass(t) {
      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);
    }
    _getAttachment(t) {
      return Ji[t.toUpperCase()];
    }
    _setListeners() {
      this._config.trigger.split(" ").forEach(t => {
        if (t === "click") {
          j.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t));
        } else if (t !== "manual") {
          const e = t === hn ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
          const i = t === hn ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          j.on(this._element, e, this._config.selector, t => this._enter(t));
          j.on(this._element, i, this._config.selector, t => this._leave(t));
        }
      });
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      j.on(this._element.closest(ln), cn, this._hideModalHandler);
      if (this._config.selector) {
        this._config = {
          ...this._config,
          trigger: "manual",
          selector: ""
        };
      } else {
        this._fixTitle();
      }
    }
    _fixTitle() {
      const t = this._element.getAttribute("title");
      const e = typeof this._element.getAttribute("data-bs-original-title");
      if (t || e !== "string") {
        this._element.setAttribute("data-bs-original-title", t || "");
        if (!!t && !this._element.getAttribute("aria-label") && !this._element.textContent) {
          this._element.setAttribute("aria-label", t);
        }
        this._element.setAttribute("title", "");
      }
    }
    _enter(t, e) {
      e = this._initializeOnDelegatedTarget(t, e);
      if (t) {
        e._activeTrigger[t.type === "focusin" ? dn : hn] = true;
      }
      if (e.getTipElement().classList.contains(sn) || e._hoverState === on) {
        e._hoverState = on;
      } else {
        clearTimeout(e._timeout);
        e._hoverState = on;
        if (e._config.delay && e._config.delay.show) {
          e._timeout = setTimeout(() => {
            if (e._hoverState === on) {
              e.show();
            }
          }, e._config.delay.show);
        } else {
          e.show();
        }
      }
    }
    _leave(t, e) {
      e = this._initializeOnDelegatedTarget(t, e);
      if (t) {
        e._activeTrigger[t.type === "focusout" ? dn : hn] = e._element.contains(t.relatedTarget);
      }
      if (!e._isWithActiveTrigger()) {
        clearTimeout(e._timeout);
        e._hoverState = rn;
        if (e._config.delay && e._config.delay.hide) {
          e._timeout = setTimeout(() => {
            if (e._hoverState === rn) {
              e.hide();
            }
          }, e._config.delay.hide);
        } else {
          e.hide();
        }
      }
    }
    _isWithActiveTrigger() {
      for (const t in this._activeTrigger) {
        if (this._activeTrigger[t]) {
          return true;
        }
      }
      return false;
    }
    _getConfig(t) {
      const e = U.getDataAttributes(this._element);
      Object.keys(e).forEach(t => {
        if (Gi.has(t)) {
          delete e[t];
        }
      });
      (t = {
        ...this.constructor.Default,
        ...e,
        ...(typeof t == "object" && t ? t : {})
      }).container = t.container === false ? document.body : r(t.container);
      if (typeof t.delay == "number") {
        t.delay = {
          show: t.delay,
          hide: t.delay
        };
      }
      if (typeof t.title == "number") {
        t.title = t.title.toString();
      }
      if (typeof t.content == "number") {
        t.content = t.content.toString();
      }
      a(Qi, t, this.constructor.DefaultType);
      if (t.sanitize) {
        t.template = Yi(t.template, t.allowList, t.sanitizeFn);
      }
      return t;
    }
    _getDelegateConfig() {
      const t = {};
      for (const e in this._config) {
        if (this.constructor.Default[e] !== this._config[e]) {
          t[e] = this._config[e];
        }
      }
      return t;
    }
    _cleanTipClass() {
      const t = this.getTipElement();
      const e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g");
      const i = t.getAttribute("class").match(e);
      if (i !== null && i.length > 0) {
        i.map(t => t.trim()).forEach(e => t.classList.remove(e));
      }
    }
    _getBasicClassPrefix() {
      return "bs-tooltip";
    }
    _handlePopperPlacementChange(t) {
      const {
        state: e
      } = t;
      if (e) {
        this.tip = e.elements.popper;
        this._cleanTipClass();
        this._addAttachmentClass(this._getAttachment(e.placement));
      }
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = un.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t]();
        }
      });
    }
  }
  g(un);
  const fn = {
    ...un.Default,
    placement: "right",
    offset: [0, 8],
    trigger: "click",
    content: "",
    template: "<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>"
  };
  const pn = {
    ...un.DefaultType,
    content: "(string|element|function)"
  };
  const mn = {
    HIDE: "hide.bs.popover",
    HIDDEN: "hidden.bs.popover",
    SHOW: "show.bs.popover",
    SHOWN: "shown.bs.popover",
    INSERTED: "inserted.bs.popover",
    CLICK: "click.bs.popover",
    FOCUSIN: "focusin.bs.popover",
    FOCUSOUT: "focusout.bs.popover",
    MOUSEENTER: "mouseenter.bs.popover",
    MOUSELEAVE: "mouseleave.bs.popover"
  };
  class gn extends un {
    static get Default() {
      return fn;
    }
    static get NAME() {
      return "popover";
    }
    static get Event() {
      return mn;
    }
    static get DefaultType() {
      return pn;
    }
    isWithContent() {
      return this.getTitle() || this._getContent();
    }
    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header");
      this._sanitizeAndSetContent(t, this._getContent(), ".popover-body");
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    _getBasicClassPrefix() {
      return "bs-popover";
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = gn.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t]();
        }
      });
    }
  }
  g(gn);
  const _n = "scrollspy";
  const bn = {
    offset: 10,
    method: "auto",
    target: ""
  };
  const vn = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  };
  const yn = "active";
  const wn = ".nav-link, .list-group-item, .dropdown-item";
  const En = "position";
  class An extends B {
    constructor(t, e) {
      super(t);
      this._scrollElement = this._element.tagName === "BODY" ? window : this._element;
      this._config = this._getConfig(e);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      j.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process());
      this.refresh();
      this._process();
    }
    static get Default() {
      return bn;
    }
    static get NAME() {
      return _n;
    }
    refresh() {
      const t = this._scrollElement === this._scrollElement.window ? "offset" : En;
      const e = this._config.method === "auto" ? t : this._config.method;
      const n = e === En ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      V.find(wn, this._config.target).map(t => {
        const s = i(t);
        const o = s ? V.findOne(s) : null;
        if (o) {
          const t = o.getBoundingClientRect();
          if (t.width || t.height) {
            return [U[e](o).top + n, s];
          }
        }
        return null;
      }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {
        this._offsets.push(t[0]);
        this._targets.push(t[1]);
      });
    }
    dispose() {
      j.off(this._scrollElement, ".bs.scrollspy");
      super.dispose();
    }
    _getConfig(t) {
      (t = {
        ...bn,
        ...U.getDataAttributes(this._element),
        ...(typeof t == "object" && t ? t : {})
      }).target = r(t.target) || document.documentElement;
      a(_n, t, vn);
      return t;
    }
    _getScrollTop() {
      if (this._scrollElement === window) {
        return this._scrollElement.pageYOffset;
      } else {
        return this._scrollElement.scrollTop;
      }
    }
    _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
    _getOffsetHeight() {
      if (this._scrollElement === window) {
        return window.innerHeight;
      } else {
        return this._scrollElement.getBoundingClientRect().height;
      }
    }
    _process() {
      const t = this._getScrollTop() + this._config.offset;
      const e = this._getScrollHeight();
      const i = this._config.offset + e - this._getOffsetHeight();
      if (this._scrollHeight !== e) {
        this.refresh();
      }
      if (t >= i) {
        const t = this._targets[this._targets.length - 1];
        if (this._activeTarget !== t) {
          this._activate(t);
        }
      } else {
        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;
          this._clear();
          return;
        }
        for (let e = this._offsets.length; e--;) {
          if (this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (this._offsets[e + 1] === undefined || t < this._offsets[e + 1])) {
            this._activate(this._targets[e]);
          }
        }
      }
    }
    _activate(t) {
      this._activeTarget = t;
      this._clear();
      const e = wn.split(",").map(e => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`);
      const i = V.findOne(e.join(","), this._config.target);
      i.classList.add(yn);
      if (i.classList.contains("dropdown-item")) {
        V.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add(yn);
      } else {
        V.parents(i, ".nav, .list-group").forEach(t => {
          V.prev(t, ".nav-link, .list-group-item").forEach(t => t.classList.add(yn));
          V.prev(t, ".nav-item").forEach(t => {
            V.children(t, ".nav-link").forEach(t => t.classList.add(yn));
          });
        });
      }
      j.trigger(this._scrollElement, "activate.bs.scrollspy", {
        relatedTarget: t
      });
    }
    _clear() {
      V.find(wn, this._config.target).filter(t => t.classList.contains(yn)).forEach(t => t.classList.remove(yn));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = An.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t]();
        }
      });
    }
  }
  j.on(window, "load.bs.scrollspy.data-api", () => {
    V.find("[data-bs-spy=\"scroll\"]").forEach(t => new An(t));
  });
  g(An);
  const Tn = "active";
  const On = "fade";
  const Cn = "show";
  const kn = ".active";
  const Ln = ":scope > li > .active";
  class xn extends B {
    static get NAME() {
      return "tab";
    }
    show() {
      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(Tn)) {
        return;
      }
      let t;
      const e = n(this._element);
      const i = this._element.closest(".nav, .list-group");
      if (i) {
        const e = i.nodeName === "UL" || i.nodeName === "OL" ? Ln : kn;
        t = V.find(e, i);
        t = t[t.length - 1];
      }
      const s = t ? j.trigger(t, "hide.bs.tab", {
        relatedTarget: this._element
      }) : null;
      if (j.trigger(this._element, "show.bs.tab", {
        relatedTarget: t
      }).defaultPrevented || s !== null && s.defaultPrevented) {
        return;
      }
      this._activate(this._element, i);
      const o = () => {
        j.trigger(t, "hidden.bs.tab", {
          relatedTarget: this._element
        });
        j.trigger(this._element, "shown.bs.tab", {
          relatedTarget: t
        });
      };
      if (e) {
        this._activate(e, e.parentNode, o);
      } else {
        o();
      }
    }
    _activate(t, e, i) {
      const n = (!e || e.nodeName !== "UL" && e.nodeName !== "OL" ? V.children(e, kn) : V.find(Ln, e))[0];
      const s = i && n && n.classList.contains(On);
      const o = () => this._transitionComplete(t, n, i);
      if (n && s) {
        n.classList.remove(Cn);
        this._queueCallback(o, t, true);
      } else {
        o();
      }
    }
    _transitionComplete(t, e, i) {
      if (e) {
        e.classList.remove(Tn);
        const t = V.findOne(":scope > .dropdown-menu .active", e.parentNode);
        if (t) {
          t.classList.remove(Tn);
        }
        if (e.getAttribute("role") === "tab") {
          e.setAttribute("aria-selected", false);
        }
      }
      t.classList.add(Tn);
      if (t.getAttribute("role") === "tab") {
        t.setAttribute("aria-selected", true);
      }
      u(t);
      if (t.classList.contains(On)) {
        t.classList.add(Cn);
      }
      let n = t.parentNode;
      if (n && n.nodeName === "LI") {
        n = n.parentNode;
      }
      if (n && n.classList.contains("dropdown-menu")) {
        const e = t.closest(".dropdown");
        if (e) {
          V.find(".dropdown-toggle", e).forEach(t => t.classList.add(Tn));
        }
        t.setAttribute("aria-expanded", true);
      }
      if (i) {
        i();
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = xn.getOrCreateInstance(this);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t]();
        }
      });
    }
  }
  j.on(document, "click.bs.tab.data-api", "[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]", function (t) {
    if (["A", "AREA"].includes(this.tagName)) {
      t.preventDefault();
    }
    if (!c(this)) {
      xn.getOrCreateInstance(this).show();
    }
  });
  g(xn);
  const Dn = "toast";
  const Sn = "hide";
  const Nn = "show";
  const In = "showing";
  const Pn = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  const jn = {
    animation: true,
    autohide: true,
    delay: 5000
  };
  class Mn extends B {
    constructor(t, e) {
      super(t);
      this._config = this._getConfig(e);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    static get DefaultType() {
      return Pn;
    }
    static get Default() {
      return jn;
    }
    static get NAME() {
      return Dn;
    }
    show() {
      if (!j.trigger(this._element, "show.bs.toast").defaultPrevented) {
        this._clearTimeout();
        if (this._config.animation) {
          this._element.classList.add("fade");
        }
        this._element.classList.remove(Sn);
        u(this._element);
        this._element.classList.add(Nn);
        this._element.classList.add(In);
        this._queueCallback(() => {
          this._element.classList.remove(In);
          j.trigger(this._element, "shown.bs.toast");
          this._maybeScheduleHide();
        }, this._element, this._config.animation);
      }
    }
    hide() {
      if (this._element.classList.contains(Nn)) {
        if (!j.trigger(this._element, "hide.bs.toast").defaultPrevented) {
          this._element.classList.add(In);
          this._queueCallback(() => {
            this._element.classList.add(Sn);
            this._element.classList.remove(In);
            this._element.classList.remove(Nn);
            j.trigger(this._element, "hidden.bs.toast");
          }, this._element, this._config.animation);
        }
      }
    }
    dispose() {
      this._clearTimeout();
      if (this._element.classList.contains(Nn)) {
        this._element.classList.remove(Nn);
      }
      super.dispose();
    }
    _getConfig(t) {
      t = {
        ...jn,
        ...U.getDataAttributes(this._element),
        ...(typeof t == "object" && t ? t : {})
      };
      a(Dn, t, this.constructor.DefaultType);
      return t;
    }
    _maybeScheduleHide() {
      if (this._config.autohide) {
        if (!this._hasMouseInteraction && !this._hasKeyboardInteraction) {
          this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay);
        }
      }
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) {
        this._clearTimeout();
        return;
      }
      const i = t.relatedTarget;
      if (this._element !== i && !this._element.contains(i)) {
        this._maybeScheduleHide();
      }
    }
    _setListeners() {
      j.on(this._element, "mouseover.bs.toast", t => this._onInteraction(t, true));
      j.on(this._element, "mouseout.bs.toast", t => this._onInteraction(t, false));
      j.on(this._element, "focusin.bs.toast", t => this._onInteraction(t, true));
      j.on(this._element, "focusout.bs.toast", t => this._onInteraction(t, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Mn.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (e[t] === undefined) {
            throw new TypeError(`No method named "${t}"`);
          }
          e[t](this);
        }
      });
    }
  }
  R(Mn);
  g(Mn);
  return {
    Alert: W,
    Button: z,
    Carousel: st,
    Collapse: pt,
    Dropdown: hi,
    Modal: Hi,
    Offcanvas: Fi,
    Popover: gn,
    ScrollSpy: An,
    Tab: xn,
    Toast: Mn,
    Tooltip: un
  };
}); //# sourceMappingURL=bootstrap.bundle.min.js.map
